<html>
<head>
    <title>SVM Javascript</title>
    <link type="text/css" href="./jqueryui/css/ui-lightness/jquery-ui-1.8.21.custom.css" rel="Stylesheet" />
    <script type="text/javascript" src="./jqueryui/js/jquery-1.7.2.min.js"></script>
    <script type="text/javascript" src="./jqueryui/js/jquery-ui-1.8.21.custom.min.js"></script>
    <script src="./npg_include/npgmain.js"></script>
    <script src="../lib/svm.js"></script>
    <script type="text/javascript">

        /*
        This demo includes npg library (notpygamejs) that I wrote a while ago. It can
        be found on my Github page (https://github.com/karpathy/notpygamejs). It's a
        quick and dirty canvas wrapper that has some helped functions I use often.
        It's main use is to contain a main loop and expose methods update(), draw(),
        as well as some events keyUp(), mouseClick() etc.
        */


        let N= 10; //number of data points
        let data = new Array(N);
        let labels= new Array(N);
        let wb; // weights and offset structure
        let ss= 50.0; // scaling factor for drawing
        let svm= new svmjs.SVM();
        let trainstats;
        let dirty= true;
        let kernelid= 2;
        let rbfKernelSigma = 0.5;
        let Degree = 2;
        let Influence = 0;
        let svmC = 1.0;

        function myinit(){

            data[0]=[-2,0];
            data[1]= [-1,0];
            data[2]=[-0.5,0];
            data[3]=[-0.2,0];
            data[4]=[-0.1,0];
            data[5]=[0.1,0];
            data[6]=[0.2,0];
            data[7]=[0.5,0];
            data[8]=[1,0];
            data[9]=[2,0];

            /*
            data[0]=[-0.4326  ,  1.1909 ];
            data[1]= [3.0, 4.0];
            data[2]=[0.1253 , -0.0376   ];
            data[3]=[0.2877 ,   0.3273  ];
            data[4]=[-1.1465 ,   0.1746 ];
            data[5]=[1.8133 ,   2.1139  ];
            data[6]=[2.7258 ,   3.0668  ];
            data[7]=[1.4117 ,   2.0593  ];
            data[8]=[4.1832 ,   1.9044  ];
            data[9]=[1.8636 ,   1.1677  ];
            */
            labels[0]= -1;
            labels[1]= -1;
            labels[2]= -1;
            labels[3]= 1;
            labels[4]= 1;
            labels[5]= 1;
            labels[6]= 1;
            labels[7]= -1;
            labels[8]= -1;
            labels[9]= -1;

            retrainSVM();
        }

        function retrainSVM() {

            if(kernelid === 2){
                trainstats= svm.train(data, labels, { kernel: 'poly', degree: Degree, influence: Influence, C: svmC});
            }
            if(kernelid === 1) {
                trainstats= svm.train(data, labels, { kernel: 'rbf', rbfsigma: rbfKernelSigma, C: svmC});
            }
            if(kernelid === 0) {
                trainstats= svm.train(data, labels, { kernel: 'linear' , C: svmC, quadratic: true});
                wb= svm.getWeights();
            }

            dirty= true; // to redraw screen
        }

        function update(){
        }

        function draw(){
            if(!dirty) return;

            ctx.clearRect(0,0,WIDTH,HEIGHT);

            // draw decisions in the grid
            let density= 4.0;
            for(let x=0.0; x<=WIDTH; x+= density) {
                for(let y=0.0; y<=HEIGHT; y+= density) {
                    let dec= svm.marginOne([(x-WIDTH/2)/ss, (y-HEIGHT/2)/ss]);
                    if(dec>0) ctx.fillStyle = 'rgb(150,250,150)';
                    else ctx.fillStyle = 'rgb(250,150,150)';
                    ctx.fillRect(x-density/2-1, y-density-1, density+2, density+2);
                }
            }

            // draw axes
            ctx.beginPath();
            ctx.strokeStyle = 'rgb(50,50,50)';
            ctx.lineWidth = 1;
            ctx.moveTo(0, HEIGHT/2);
            ctx.lineTo(WIDTH, HEIGHT/2);
            ctx.moveTo(WIDTH/2, 0);
            ctx.lineTo(WIDTH/2, HEIGHT);
            ctx.stroke();

            // draw datapoints. Draw support vectors larger
            ctx.strokeStyle = 'rgb(0,0,0)';
            for(let i=0;i<N;i++) {

                if(labels[i]==1) ctx.fillStyle = 'rgb(100,200,100)';
                else ctx.fillStyle = 'rgb(200,100,100)';

                if(svm.alpha[i]>1e-2) ctx.lineWidth = 3; // distinguish support vectors
                else ctx.lineWidth = 1;

                drawCircle(data[i][0]*ss+WIDTH/2, data[i][1]*ss+HEIGHT/2, Math.floor(3+svm.alpha[i]*5.0/svmC));
            }

            // if linear kernel, draw decision boundary and margin lines
            if(kernelid == 0) {

                let xs= [-5, 5];
                let ys= [0, 0];
                ys[0]= (-wb.b - wb.w[0]*xs[0])/wb.w[1];
                ys[1]= (-wb.b - wb.w[0]*xs[1])/wb.w[1];
                ctx.fillStyle = 'rgb(0,0,0)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                // wx+b=0 line
                ctx.moveTo(xs[0]*ss+WIDTH/2, ys[0]*ss+HEIGHT/2);
                ctx.lineTo(xs[1]*ss+WIDTH/2, ys[1]*ss+HEIGHT/2);
                // wx+b=1 line
                ctx.moveTo(xs[0]*ss+WIDTH/2, (ys[0]-1.0/wb.w[1])*ss+HEIGHT/2);
                ctx.lineTo(xs[1]*ss+WIDTH/2, (ys[1]-1.0/wb.w[1])*ss+HEIGHT/2);
                // wx+b=-1 line
                ctx.moveTo(xs[0]*ss+WIDTH/2, (ys[0]+1.0/wb.w[1])*ss+HEIGHT/2);
                ctx.lineTo(xs[1]*ss+WIDTH/2, (ys[1]+1.0/wb.w[1])*ss+HEIGHT/2);
                ctx.stroke();

                // draw margin lines for support vectors. The sum of the lengths of these
                // lines, scaled by C is essentially the total hinge loss.
                for(let i=0;i<N;i++) {
                    if(svm.alpha[i]<1e-2) continue;
                    if(labels[i]===1) {
                        ys[0]= (1 -wb.b - wb.w[0]*xs[0])/wb.w[1];
                        ys[1]= (1 -wb.b - wb.w[0]*xs[1])/wb.w[1];
                    } else {
                        ys[0]= (-1 -wb.b - wb.w[0]*xs[0])/wb.w[1];
                        ys[1]= (-1 -wb.b - wb.w[0]*xs[1])/wb.w[1];
                    }
                    let u= (data[i][0]-xs[0])*(xs[1]-xs[0])+(data[i][1]-ys[0])*(ys[1]-ys[0]);
                    u = u/((xs[0]-xs[1])*(xs[0]-xs[1])+(ys[0]-ys[1])*(ys[0]-ys[1]));
                    let xi= xs[0]+u*(xs[1]-xs[0]);
                    let yi= ys[0]+u*(ys[1]-ys[0]);
                    ctx.moveTo(data[i][0]*ss+WIDTH/2, data[i][1]*ss+HEIGHT/2);
                    ctx.lineTo(xi*ss+WIDTH/2, yi*ss+HEIGHT/2);
                }
                ctx.stroke();
            }

            ctx.fillStyle= 'rgb(0,0,0)';
            ctx.fillText("Converged in " + trainstats.iters + " iterations.", 10, HEIGHT-30);
            let numsupp=0;
            for(let i=0;i<N;i++) { if(svm.alpha[i] > 1e-5) numsupp++; }
            ctx.fillText("Number of support vectors: " + numsupp + " / " + N, 10, HEIGHT-50);

            $(".slider_container").hide(); // per nascondere gli slider che non servono

            if(kernelid === 2){
                ctx.fillText("Using Polynomial kernel with degree = " + Degree, 10, HEIGHT - 70);
                ctx.fillText("Influence = " + Influence, 10, HEIGHT - 90);
                $("#s3").show();
                $("#s4").show();
            }
            if(kernelid === 1){
                ctx.fillText("Using Rbf kernel with sigma = " + rbfKernelSigma.toPrecision(2), 10, HEIGHT - 70);
                $("#s2").show();
            }
            if(kernelid === 0) ctx.fillText("Using Linear kernel", 10, HEIGHT - 70);

            $("#s1").show();

            ctx.fillText("C = " + svmC.toPrecision(2), 10, HEIGHT - 110);
        }

        function mouseClick(x, y, shiftPressed){

            // add datapoint at location of click
            data[N] = [(x-WIDTH/2)/ss, (y-HEIGHT/2)/ss];
            labels[N] = shiftPressed ? 1 : -1;
            N += 1;

            // retrain the svm
            retrainSVM();
        }

        function keyUp(key){

            if(key==82) { // 'r'

                // reset to original data and retrain
                data= data.splice(0, 10);
                labels= labels.splice(0, 10);
                N= 10;
                retrainSVM();
            }
            /*
            if(key==75) { // 'k'

              // toggle between kernels: rbf or linear
              kernelid= 1-kernelid; // toggle 1 and 0
              retrainSVM();
            }*/
        }

        function changeKernel(id){
            if(kernelid !== id){
                kernelid = id;
                retrainSVM();
            }
        }

        function keyDown(key){
        }


        // UI stuff
        function refreshC(event, ui) {
            let logC = ui.value;
            svmC= Math.pow(10, logC);
            $("#creport").text("C = " + svmC.toPrecision(2));
            retrainSVM();
        }

        function refreshSig(event, ui) {
            let logSig = ui.value;
            rbfKernelSigma= Math.pow(10, logSig);
            $("#sigreport").text("RBF Kernel sigma = " + rbfKernelSigma.toPrecision(2));
            if(kernelid === 1) {
                retrainSVM();
            }
        }

        function refreshDegree(event, ui) {
            //let logDegree = ui.value;
            //Degree = Math.pow(10, logDegree);
            Degree = ui.value;
            $("#degport").text("Polynomial Kernel degree = " + Degree.toPrecision(2));
            if(kernelid === 2) {
                retrainSVM();
            }
        }

        function refreshInfluence(event, ui) {
            Influence =  ui.value;
            $("#infport").text("Polynomial Kernel influence = " + Influence.toPrecision(2));
            if(kernelid === 2) {
                retrainSVM();
            }
        }

        $(function() {
            // for C parameter
            $("#slider1").slider({
                orientation: "horizontal",
                slide: refreshC,
                max: 2.0,
                min: -2.0,
                step: 0.1,
                value: 0.0
            });

            // for rbf kernel sigma
            $("#slider2").slider({
                orientation: "horizontal",
                slide: refreshSig,
                max: 2.0,
                min: -2.0,
                step: 0.1,
                value: 0.0
            });

            // for polynomial kernel degree
            $("#slider3").slider({
                orientation: "horizontal",
                slide: refreshDegree,
                max: 5.0,
                min: 1.0,
                step: 1.0,
                value: 2.0
            });

            // for polynomial kernel influence
            $("#slider4").slider({
                orientation: "horizontal",
                slide: refreshInfluence,
                max: 3.0,
                min: 0.0,
                step: 0.1,
                value: 0.0
            });

        });
    </script>

    <style type="text/css">
        canvas {
            border: 1px solid #555;
            margin-top: 10px;
        }
        body {
            text-align: center;
            font-family: Verdana, Helvetica, sans-serif;
            font-size: 12px;
            padding: 0;
            margin: 0;
        }
        h1 {
            font-size: 16px;
        }
        p {
            padding-top: 0;
            padding-bottom: 0;
        }
        #dec {
            width: 100%;
            height: 120px;
            background-color: #fffda4;
            border-bottom: 1px solid #000000;
            margin-bottom: 20px;
        }
        #optsdiv {
            width: 800px;
            margin-left: auto;
            margin-right: auto;
        }
    </style>

</head>

<body onLoad="NPGinit(10);">
<div id="dec">
    <br /><h1>Support Vector Machine in Javascript (Pratice Mode)</h1>
    <p>
        Uses SMO algorithm. Find this code on <a href="https://github.com/davide97g/svmjs">Github</a> <br />
        This version is based on the work of Andrej Karpathy.<br/>Find his code on <a href="https://github.com/karpathy/svmjs">Github</a>.
    </p>
</div>

<p>
    <b>mouse click</b>: add red data point<br />
    <b>shift + mouse click</b>: add green data point<br />
    <!--<b>'k'</b>: toggle between Linear and Rbf kernel<br />-->
    <b>'r'</b>: reset<br /><br />
    <button onclick="changeKernel(0)">Linear Kernel</button>
    <button onclick="changeKernel(1)">RBF Kernerl</button>
    <button onclick="changeKernel(2)">Polynomial Kernel</button>
</p>


<canvas id="NPGcanvas" width="450" height="450">Browser not supported for Canvas. Get a real browser.</canvas><br /><br />

<div id="optsdiv">
    <div id="s1" class="slider_container" style="width:250px; float: left; margin-left: 10px;">
        <div id="slider1"></div>
        <br/>
        <span id="creport">C = 1.0</span>
    </div>

    <div id="s2" class="slider_container" style="width:250px; float: right; margin-right: 10px;">
        <div id="slider2"></div>
        <br/>
        <span id="sigreport">RBF Kernel sigma = 1.0</span>
    </div>
    <div id="s3" class="slider_container" style="width:250px; float: right; margin-right: 10px;">
        <div id="slider3"></div>
        <br/>
        <span id="degport">Polynomial Kernel degree = 2</span>
    </div>
    <div id="s4" class="slider_container" style="width:250px; float: right; margin-right: 10px;">
        <div id="slider4"></div>
        <br/>
        <span id="infport">Polynomial Kernel influence = 0</span>
    </div>
</div>


</body>
</html>
