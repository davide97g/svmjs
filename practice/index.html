<!DOCTYPE html>
<html lang="it">
    <head>
        <title>SVM Javascript</title>
        <link type="text/css" href="./jqueryui/css/ui-lightness/jquery-ui-1.8.21.custom.css" rel="Stylesheet" />
        <link type="text/css" rel="stylesheet" href="style/style.css"/>
        <script type="text/javascript" src="./jqueryui/js/jquery-1.7.2.min.js"></script>
        <script type="text/javascript" src="./jqueryui/js/jquery-ui-1.8.21.custom.min.js"></script>
        <script src="./npg_include/npgmain.js"></script>

        <script src="../lib/stats.js"></script>
        <script src="../lib/utils.js"></script>
        <script src="../lib/kernels.js"></script>

        <script src="../lib/svm.js"></script>

        <!-- Declaration and initialization -->
        <script type="text/javascript">

        /*
        This demo includes npg library (notpygamejs) that I wrote a while ago. It can
        be found on my Github page (https://github.com/karpathy/notpygamejs). It's a
        quick and dirty canvas wrapper that has some helped functions I use often.
        It's main use is to contain a main loop and expose methods update(), draw(),
        as well as some events keyUp(), mouseClick() etc.
        */

        let N = 10; //number of data points
        let data = new Array(N);
        let labels = new Array(N);
        let wb; // weights and offset structure
        let ss= 50.0; // scaling factor for drawing
        let svm= new svmjs.SVM();
        let dirty= true;
        let rbfKernelSigma = 0.5;
        let svmC = 1.0;
        let memo = true;

        let trainstats = {
            data: null,
            labels: null,
            CM:null,
            recall: null,
            precision : null,
            accurancy : null,
            specificity : null,
            fMeasure : null
        };

        let kernelid= 3;
        let Degree = 2;
        let Influence = 0;
        let ssca = false;
        let ub = 0.5;
        let CM;
        let recall;
        let precision;
        let accurancy;
        let specificity;
        let fMeasure;
        let K = 1; //for KNN
        let P = 2; //for minkowski
        let v; //array of variances
        let distanceid = 0; //for distances in KNN evalutations

        function setDataSet(id) {
            if(id===-1){
                for(let i=0;i<N;i++){
                    data[i] = [randf(-3,3),randf(-3,3)];
                    if(randi(0,2))
                        labels[i] = 1;
                    else labels[i] = -1;
                }
                //console.table(labels);
            }
            else if(id===0){
                data[0]=[-0.4326  ,  1.1909 ];
                data[1]= [3.0, 4.0];
                data[2]=[0.1253 , -0.0376   ];
                data[3]=[0.2877 ,   0.3273  ];
                data[4]=[-1.1465 ,   0.1746 ];
                data[5]=[1.8133 ,   2.1139  ];
                data[6]=[2.7258 ,   3.0668  ];
                data[7]=[1.4117 ,   2.0593  ];
                data[8]=[4.1832 ,   1.9044  ];
                data[9]=[1.8636 ,   1.1677  ];

                labels[0]= 1;
                labels[1]= 1;
                labels[2]= 1;
                labels[3]= 1;
                labels[4]= 1;
                labels[5]= -1;
                labels[6]= -1;
                labels[7]= -1;
                labels[8]= -1;
                labels[9]= -1;
            }
            else if(id===1){
                data[0]=[-2,0];
                data[1]= [-1,0];
                data[2]=[-0.5,0];
                data[3]=[-0.2,0];
                data[4]=[-0.1,0];
                data[5]=[0.1,0];
                data[6]=[0.2,0];
                data[7]=[0.5,0];
                data[8]=[1,0];
                data[9]=[2,0];

                labels[0]= -1;
                labels[1]= -1;
                labels[2]= -1;
                labels[3]= -1;
                labels[4]= -1;
                labels[5]= 1;
                labels[6]= 1;
                labels[7]= 1;
                labels[8]= 1;
                labels[9]= 1;
            }
            else if(id===2){
                data[0]=[-0.4326  ,  -1.1909 ];
                data[1]= [-3.0, -4.0];
                data[2]=[-0.1253 , -0.0376   ];
                data[3]=[-0.2877 ,   -0.3273  ];
                data[4]=[-1.1465 ,   -0.1746 ];
                data[5]=[1.8133 ,   2.1139  ];
                data[6]=[2.7258 ,   3.0668  ];
                data[7]=[1.4117 ,   2.0593  ];
                data[8]=[4.1832 ,   1.9044  ];
                data[9]=[1.8636 ,   1.1677  ];

                labels[0]= 1;
                labels[1]= 1;
                labels[2]= 1;
                labels[3]= 1;
                labels[4]= 1;
                labels[5]= -1;
                labels[6]= -1;
                labels[7]= -1;
                labels[8]= -1;
                labels[9]= -1;
            }
        }

        function retrainSVM() {

            if(kernelid === 2){
                trainstats= svm.train(data, labels, { kernel: 'poly', degree: Degree, influence: Influence, C: svmC, SSCA: ssca, UB: ub, memoize: memo});
                if(Degree === 1)
                    wb = svm.getWeights();
            }
            if(kernelid === 1) {
                trainstats= svm.train(data, labels, { kernel: 'rbf', rbfsigma: rbfKernelSigma, C: svmC, SSCA: ssca, UB: ub, memoize: memo});
            }
            if(kernelid === 0) {
                kernelid = 2;
                Degree = 1;
                retrainSVM();
                //trainstats= svm.train(data, labels, { kernel: 'linear' , C: svmC, quadratic: false, SSCA: ssca, UB: ub, memoize: memo});
                //wb= svm.getWeights();
            }
            if(kernelid===3){
                addClassSelected("knn");
                console.info("KNN: "+K);
                console.info("distance with: ");
                if(distanceid===0){
                    addClassSelected("min");
                    console.info("minkowski with p = "+P);
                }
                else if(distanceid === 1 ){
                    addClassSelected("che");
                    console.info("chebyshev");
                }
                else if(distanceid === 2){ //mahalanobis
                    addClassSelected("maha");
                    console.info("mahalanobis");
                    v = variance(); //calcolo una volta sola per aggiornamento di data set
                }
            }
            if(kernelid===4){
                console.info("RBF");
            }

            dirty= true; // to redraw screen
        }

        function myinit(){
            clickBtn("knn");
            setDataSet(0);
            retrainSVM();
        }
        function clickBtn(ID) {
            removeAll();
            addClassSelected(ID);
        }
        function addClassSelected(ID) {
            document.getElementById(ID).classList.add("selected");
        }
        function removeAll() {
            let buttons = document.getElementsByTagName("button");
            for (let i=0;i<buttons.length;i++){
                removeAllClasses(buttons.item(i).id);
            }
        }
        function removeAllClasses(ID) {
            let list = document.getElementById(ID).classList;
            for(let i=0;i<list.length;i++)
                list.remove(list[i]);
        }

        </script>

        <!-- distances functions (minkowski, chebyshev, mahalanobis) -->
        <script type="text/javascript" src="js/distances.js"></script>

        <!-- evaluations functions (KNN and RBF) -->
        <script type="text/javascript" src="js/evaluations.js"></script>

        <!-- draw, mouseClick, keyUp, kewDown -->
        <script type="text/javascript">

            function update(){
                CM = trainstats.CM;
                recall = trainstats.recall;
                precision = trainstats.precision;
                accurancy = trainstats.accurancy;
                specificity = trainstats.specificity;
                fMeasure = trainstats.fMeasure;
                if(kernelid<3){
                    data = trainstats.data;
                    labels = trainstats.labels;
                }
            }

            function draw(){
                if(!dirty) return;
                dirty = false;

                ctx.clearRect(0,0,WIDTH,HEIGHT);
                update();

                let optimization = $("#optimization");
                let distances = $("#distances");
                distances.hide();
                optimization.hide();

                $(".slider_container").hide(); // per nascondere gli slider che non servono

                if(kernelid>=3){

                    if(kernelid===3) {
                        $("#s6").show(); //slider for K in KNN
                        distances.show();
                        if(distanceid===0)  //minkowski
                            $("#s7").show(); //slider for minkowski

                    }

                    // draw decisions in the grid
                    let density = 1;
                    for(let x=0.0; x<=WIDTH; x+= density) {
                        for(let y=0.0; y<=HEIGHT; y+= density) {
                            let label;
                            if(kernelid===3) { //KNN
                                label = KNN((x - WIDTH / 2) / ss, (y - HEIGHT / 2) / ss,K);
                            }
                            else if(kernelid===4){ //RBF
                                label = RBF((x - WIDTH / 2) / ss, (y - HEIGHT / 2) / ss);
                            }
                            if(label === 1) ctx.fillStyle = 'rgb(150,250,150)'; //green
                            //else if(label === 0) ctx.fillStyle = 'rgb(191,244,66)'; //yellow lime
                            //else if(label === 0) ctx.fillStyle = 'rgb(244,161,66)'; //orange
                            else if(label === 0) ctx.fillStyle = 'rgb(244,220,66)'; //yellow gold
                            else ctx.fillStyle = 'rgb(250,150,150)'; //red
                            ctx.fillRect(x-density/2-1, y-density-1, density+2, density+2);
                        }
                    }

                    // draw axes
                    ctx.beginPath();
                    ctx.strokeStyle = 'rgb(50,50,50)';
                    ctx.lineWidth = 1;
                    ctx.moveTo(0, HEIGHT/2);
                    ctx.lineTo(WIDTH, HEIGHT/2);
                    ctx.moveTo(WIDTH/2, 0);
                    ctx.lineTo(WIDTH/2, HEIGHT);
                    ctx.stroke();

                    // draw datapoints
                    ctx.strokeStyle = 'rgb(0,0,0)';
                    N = data.length;
                    let radius = 3;
                    console.info("DRAW: "+N+"🔥");
                    for(let i=0;i<N;i++) {
                        if(labels[i]===1) //positive
                            ctx.fillStyle = 'rgb(100,200,100)'; //green
                        else //negative
                            ctx.fillStyle = 'rgb(200,100,100)'; //red
                        drawCircle(data[i][0]*ss+WIDTH/2, data[i][1]*ss+HEIGHT/2, radius);
                    }

                    return;
                }

                optimization.show();

                // draw decisions in the grid
                let density= 2;
                for(let x=0.0; x<=WIDTH; x+= density) {
                    for(let y=0.0; y<=HEIGHT; y+= density) {
                        let dec= svm.marginOne([(x-WIDTH/2)/ss, (y-HEIGHT/2)/ss]);
                        if(dec>0) ctx.fillStyle = 'rgb(150,250,150)';
                        else ctx.fillStyle = 'rgb(250,150,150)';
                        ctx.fillRect(x-density/2-1, y-density-1, density+2, density+2);
                    }
                }

                // draw axes
                ctx.beginPath();
                ctx.strokeStyle = 'rgb(50,50,50)';
                ctx.lineWidth = 1;
                ctx.moveTo(0, HEIGHT/2);
                ctx.lineTo(WIDTH, HEIGHT/2);
                ctx.moveTo(WIDTH/2, 0);
                ctx.lineTo(WIDTH/2, HEIGHT);
                ctx.stroke();

                // draw datapoints. Draw support vectors larger
                ctx.strokeStyle = 'rgb(0,0,0)';
                N = data.length;
                let value = 0;
                let radius = 0;
                console.info("DRAW: "+N+"🔥");
                for(let i=0;i<N;i++) {
                    value = svm.marginOne(data[i]);
                    if(value>0){ //positive
                        if(labels[i]===1) //positive
                            ctx.fillStyle = 'rgb(100,200,100)'; //green
                        else { //false positive
                            ctx.fillStyle = 'rgb(55,55,250)'; //blue
                        }
                    }
                    else {
                        if(labels[i]===1) //false negative
                            ctx.fillStyle = 'rgb(240,240,80)'; //yellow
                        else //negative
                            ctx.fillStyle = 'rgb(200,100,100)'; //red
                    }

                    if(svm.alpha[i]>1e-7) {
                        ctx.lineWidth = 3; // distinguish support vectors
                        radius = Math.floor(3+svm.alpha[i]*5.0/svmC);
                    }
                    else{
                        ctx.lineWidth = 1;
                        radius = 4;
                    }

                    drawCircle(data[i][0]*ss+WIDTH/2, data[i][1]*ss+HEIGHT/2, radius);
                }

                // if linear kernel, draw decision boundary and margin lines
                //modified: also if kernel is polynomial and degree is 1: should be equal to linear kernel
                if( kernelid===0 || (kernelid === 2 && Degree ===  1)) {

                    let xs= [-5, 5];
                    let ys= [0, 0];
                    wb.b = -wb.b;
                    ys[0]= (-wb.b - wb.w[0]*xs[0])/wb.w[1];
                    ys[1]= (-wb.b - wb.w[0]*xs[1])/wb.w[1];
                    ctx.fillStyle = 'rgb(0,0,0)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    // wx+b=0 line
                    ctx.moveTo(xs[0]*ss+WIDTH/2, ys[0]*ss+HEIGHT/2);
                    ctx.lineTo(xs[1]*ss+WIDTH/2, ys[1]*ss+HEIGHT/2);
                    // wx+b=1 line
                    ctx.moveTo(xs[0]*ss+WIDTH/2, (ys[0]-1.0/wb.w[1])*ss+HEIGHT/2);
                    ctx.lineTo(xs[1]*ss+WIDTH/2, (ys[1]-1.0/wb.w[1])*ss+HEIGHT/2);
                    // wx+b=-1 line
                    ctx.moveTo(xs[0]*ss+WIDTH/2, (ys[0]+1.0/wb.w[1])*ss+HEIGHT/2);
                    ctx.lineTo(xs[1]*ss+WIDTH/2, (ys[1]+1.0/wb.w[1])*ss+HEIGHT/2);
                    ctx.stroke();

                    // draw margin lines for support vectors. The sum of the lengths of these
                    // lines, scaled by C is essentially the total hinge loss.
                    for(let i=0;i<N;i++) {
                        if(svm.alpha[i]<1e-2) continue;
                        if(labels[i]===1) {
                            ys[0]= (1 -wb.b - wb.w[0]*xs[0])/wb.w[1];
                            ys[1]= (1 -wb.b - wb.w[0]*xs[1])/wb.w[1];
                        } else {
                            ys[0]= (-1 -wb.b - wb.w[0]*xs[0])/wb.w[1];
                            ys[1]= (-1 -wb.b - wb.w[0]*xs[1])/wb.w[1];
                        }
                        let u= (data[i][0]-xs[0])*(xs[1]-xs[0])+(data[i][1]-ys[0])*(ys[1]-ys[0]);
                        u = u/((xs[0]-xs[1])*(xs[0]-xs[1])+(ys[0]-ys[1])*(ys[0]-ys[1]));
                        let xi= xs[0]+u*(xs[1]-xs[0]);
                        let yi= ys[0]+u*(ys[1]-ys[0]);
                        ctx.moveTo(data[i][0]*ss+WIDTH/2, data[i][1]*ss+HEIGHT/2);
                        ctx.lineTo(xi*ss+WIDTH/2, yi*ss+HEIGHT/2);
                    }
                    ctx.stroke();
                }

                ctx.fillStyle= 'rgb(0,0,0)';

                ctx.fillText("Recall " + (recall*100).toPrecision(3) +"%" , 10, HEIGHT-210);
                ctx.fillText("Precision " + (precision*100).toPrecision(3) +"%" , 10, HEIGHT-190);
                ctx.fillText("Accurancy " + (accurancy*100).toPrecision(3) +"%" , 10, HEIGHT-170);
                ctx.fillText("Specificity " + (specificity*100).toPrecision(3) +"%" , 10, HEIGHT-150);
                ctx.fillText("FMeasure " + (fMeasure*100).toPrecision(3) +"%" , 10, HEIGHT-130);
                ctx.fillText("Converged in " + trainstats.iters + " iterations.", 10, HEIGHT-30);

                let numsupp=0;
                for(let i=0;i<N;i++) { if(svm.alpha[i] > 1e-5) numsupp++; }
                ctx.fillText("Number of support vectors: " + numsupp + " / " + N, 10, HEIGHT-50);

                if(kernelid === 2){
                    ctx.fillText("Using Polynomial kernel with degree = " + Degree, 10, HEIGHT - 70);
                    ctx.fillText("Influence = " + Influence, 10, HEIGHT - 90);
                    $("#s3").show();
                    $("#s4").show();
                }
                if(kernelid === 1){
                    ctx.fillText("Using Rbf kernel with sigma = " + rbfKernelSigma.toPrecision(2), 10, HEIGHT - 70);
                    $("#s2").show();
                }
                if(kernelid === 0) ctx.fillText("Using Linear kernel", 10, HEIGHT - 70);

                if(ssca) $("#s5").show();

                $("#s1").show();

                ctx.fillText("C = " + svmC.toPrecision(2), 10, HEIGHT - 110);
            }

            function mouseClick(x, y, shiftPressed){

                // add datapoint at location of click
                data[N] = [(x-WIDTH/2)/ss, (y-HEIGHT/2)/ss];
                labels[N] = shiftPressed ? 1 : -1;
                N += 1;

                // retrain the svm
                retrainSVM();
            }

            function keyUp(key){

                if(key===82) { // 'r'

                    // reset to original data and retrain
                    data= data.splice(0, 10);
                    labels= labels.splice(0, 10);
                    N= 10;
                    retrainSVM();
                }
                if(key===48){ //0
                    data = data.splice(0,10);
                    setDataSet(0);
                    retrainSVM();
                }
                if(key===49){ //1
                    data = data.splice(0,10);
                    setDataSet(1);
                    retrainSVM();
                }
                if(key===50){ //2
                    data = data.splice(0,10);
                    setDataSet(2);
                    retrainSVM();
                }
                if(key===51){ //3
                    N = 100;
                    data = new Array(N);
                    setDataSet(-1);
                    retrainSVM();
                }
                /*
                if(key==75) { // 'k'

                  // toggle between kernels: rbf or linear
                  kernelid= 1-kernelid; // toggle 1 and 0
                  retrainSVM();
                }*/
            }

            function keyDown(key){}

        </script>

        <!-- ui functions -->
        <script type="text/javascript" src="js/ui.js"></script>

        <!-- jquery/set functions -->
        <script type="text/javascript" src="js/functions.js"></script>

    </head>

    <body onLoad="NPGinit(10);"> <!-- 24 FPS -->
        <div id="dec">
            <br /><h1>Support Vector Machine in Javascript (Pratice Mode) 🐧✌️</h1>
            <p>
                Uses SMO algorithm. Find this code on <a href="https://github.com/davide97g/svmjs">Github</a> <br />
                This version is based on the work of Andrej Karpathy.<br/>Find his code on <a href="https://github.com/karpathy/svmjs">Github</a>.
            </p>
        </div>
        <div id="options">
            <div id="instructions" class="opts">
                <b>Mouse click</b>: add red data point<br />
                <b>Shift + mouse click</b>: add green data point<br />
                <b>'r'</b>: reset<br /><br />
            </div>
            <div id="kernels" class="opts">
                <b>Kernels: </b>
                <button id="linear" onclick="clickBtn(id),changeKernel(0)">Linear Kernel</button>
                <button id="rbfk" onclick="clickBtn(id),changeKernel(1)">RBF Kernerl</button>
                <button id="poly" onclick="clickBtn(id),changeKernel(2)">Polynomial Kernel</button>
            </div>
            <div id="optimization" class="opts">
                <b>Optimization: </b>
                <button id="SSCAtoggle" onclick="toggleSSCA(!ssca)">SSCA off</button>
            </div>
            <div id="evalutation" class="opts">
                <b>Evaluation functions:</b>
                <button id="knn" onclick="clickBtn(id),changeKernel(3)">KNN</button>
                <button id="rbf" onclick="clickBtn(id),changeKernel(4)">RBF function</button>
            </div>
            <div id="distances" class="opts">
                <b>Distances functions:</b>
                <button id="min" onclick="clickBtn(id),changeDistance(0)">Minkowski</button>
                <button id="che" onclick="clickBtn(id),changeDistance(1)">Chebyshev</button>
                <button id="maha" onclick="clickBtn(id),changeDistance(2)">Mahalanobis</button>
            </div>
        </div>
        <canvas id="NPGcanvas" width="450" height="450">Browser not supported for Canvas. Get a real browser.
        </canvas>
        <br /><br />
        <div id="optsdiv">
            <div id="s1" class="slider_container">
                <div id="slider1"></div>
                <br/>
                <span id="creport">C = 1.0</span>
            </div>
            <div id="s2" class="slider_container">
                <div id="slider2"></div>
                <br/>
                <span id="sigreport">RBF Kernel sigma = 1.0</span>
            </div>
            <div id="s3" class="slider_container">
                <div id="slider3"></div>
                <br/>
                <span id="degport">Polynomial Kernel degree = 2</span>
            </div>
            <div id="s4" class="slider_container">
                <div id="slider4"></div>
                <br/>
                <span id="infport">Polynomial Kernel influence = 0</span>
            </div>
            <div id="s5" class="slider_container">
                <div id="slider5"></div>
                <br/>
                <span id="ubport">Upper bound = 0.5</span>
            </div>
            <div id="s6" class="slider_container">
                <div id="slider6"></div>
                <br/>
                <span id="kport">K: 1</span>
            </div>
            <div id="s7" class="slider_container">
            <div id="slider7"></div>
                <br/>
                <span id="pport">Minkowski with P: 2</span>
            </div>
        </div>
    </body>
</html>
