<!DOCTYPE html>
<html lang="it">
    <head>
        <title>SVM Javascript</title>
        <link type="text/css" href="./jqueryui/css/ui-lightness/jquery-ui-1.8.21.custom.css" rel="Stylesheet" />
        <link type="text/css" rel="stylesheet" href="style/style.css"/>
        <script type="text/javascript" src="./jqueryui/js/jquery-1.7.2.min.js"></script>
        <script type="text/javascript" src="./jqueryui/js/jquery-ui-1.8.21.custom.min.js"></script>
        <script src="./npg_include/npgmain.js"></script>
        <script src="./npg_include/drawTest.js"></script>

        <script src="../lib/stats.js"></script>
        <script src="../lib/utils.js"></script>
        <script src="../lib/kernels.js"></script>

        <script src="./js/kmeans.js"></script>
        <script src="../lib/svm.js"></script>
        <script src="../lib/svmo.js"></script>

        <script type="text/javascript" src="./js/generator.js"></script>
        <!-- Declaration and initialization -->
        <script type="text/javascript">

        /*
        This demo includes npg library (notpygamejs) that I wrote a while ago. It can
        be found on my Github page (https://github.com/karpathy/notpygamejs). It's a
        quick and dirty canvas wrapper that has some helped functions I use often.
        It's main use is to contain a main loop and expose methods update(), draw(),
        as well as some events keyUp(), mouseClick() etc.
        */

        let N = 10; //number of data points
        let Ntest = 10;
        let data = new Array(N);
        let labels = new Array(N);
        let datatest = new Array(N);
        let labelstest = new Array(N);
        let dataOLD = new Array(N);
        let labelsOLD = new Array(N);
        let wb; // weights and offset structure
        let ss= 50.0; // scaling factor for drawing
        let svm= new svmjs.SVM();
        let svmo = new svmojs.SVMO();
        let dirty= true;
        let rbfKernelSigma = 0.5;
        let svmC = 1.0;
        let memo = true;

        let trainstats = {
            data: null,
            labels: null,
            CM:null,
            recall: null,
            precision : null,
            accurancy : null,
            specificity : null,
            fMeasure : null
        };

        let kernelid= 4;
        let Degree = 2;
        let Influence = 0;
        let ssca = false;
        let ub = 0.5;
        let CM;
        let recall;
        let precision;
        let accurancy;
        let specificity;
        let fMeasure;
        let K = 1; //for KNN
        let P = 2; //for minkowski
        let v; //array of variances
        let distanceid = 0; //for distances in KNN evalutations
        let datasetID = 1; //initially random
        let Epsilon = 0.1; //for rbf function evaluation
        let Km1 = 3; //K for kmeans
        let Km2 = 3; //K for kmeans
        let KMdata = false; //use or not Kmeans as data
        let useTest = false; //show the tests
        let density = 2; //drawing canvas points

        let canvasResult = "canvasResult";
        let canvasData = "canvasData";

        function setDataSet(id) {
            if(kernelid===4 && KMdata){
                N = dataOLD.length;
            }
            datasetID = id;
            if(id===0){
                //data = data.splice(0,10);
                data[0]=[-0.4326  ,  1.1909 ];
                data[1]= [3.0, 4.0];
                data[2]=[0.1253 , -0.0376   ];
                data[3]=[0.2877 ,   0.3273  ];
                data[4]=[-1.1465 ,   0.1746 ];
                data[5]=[1.8133 ,   2.1139  ];
                data[6]=[2.7258 ,   3.0668  ];
                data[7]=[1.4117 ,   2.0593  ];
                data[8]=[4.1832 ,   1.9044  ];
                data[9]=[1.8636 ,   1.1677  ];

                labels[0]= 1;
                labels[1]= 1;
                labels[2]= 1;
                labels[3]= 1;
                labels[4]= 1;
                labels[5]= -1;
                labels[6]= -1;
                labels[7]= -1;
                labels[8]= -1;
                labels[9]= -1;
            }
            else if(id===1){
                let res = randomData(N);
                data = res.data;
                labels = res.labels;
            }
            else if(id===2){
                let res = circelData(N);
                data = res.data;
                labels = res.labels;
            }
            else if(id===3){
                let res = exclusiveOrData(N);
                data = res.data;
                labels = res.labels;
            }
            else if(id===4){
                let res = gaussianData(N);
                data = res.data;
                labels = res.labels;
            }
            else if(id===5){
                let res = spiralData(N);
                data = res.data;
                labels = res.labels;
            }
        }
        function setTrainingSet(id) {
            if(id===1){
                let res = randomData(Ntest);
                datatest = res.data;
                labelstest = res.labels;
            }
            else if(id===2){
                let res = circelData(Ntest);
                datatest = res.data;
                labelstest = res.labels;
            }
            else if(id===3){
                let res = exclusiveOrData(Ntest);
                datatest = res.data;
                labelstest = res.labels;
            }
            else if(id===4){
                let res = gaussianData(Ntest);
                datatest = res.data;
                labelstest = res.labels;
            }
            else if(id===5){
                let res = spiralData(Ntest);
                datatest = res.data;
                labelstest = res.labels;
            }
        }

        function retrainSVM() {
            console.clear();
            console.info("üêµ DATASET "+datasetID);
            if(kernelid === 0) {
                kernelid = 2;
                Degree = 1;
                retrainSVM();
            }
            else if(kernelid === 1) {
                addClassSelected("rbfk");
                ssca = document.getElementById("ssca").checked;
                trainstats= svm.train(data, labels, { kernel: 'rbf', rbfsigma: rbfKernelSigma, C: svmC, SSCA: ssca, UB: ub, memoize: memo});
            }
            else if(kernelid === 2){
                addClassSelected("poly");
                ssca = document.getElementById("ssca").checked;
                trainstats= svm.train(data, labels, { kernel: 'poly', degree: Degree, influence: Influence, C: svmC, SSCA: ssca, UB: ub, memoize: memo});
                if(Degree === 1)
                    wb = svm.getWeights();
            }
            else if(kernelid === 3){
                addClassSelected("knn");
                console.info("\tKNN: "+K);
                console.info("\tDISTANCE: "+distanceF.name);
                if(distanceid===0){
                    addClassSelected("min");
                    console.info("\tP = "+P);
                }
                else if(distanceid === 1 ){
                    addClassSelected("che");
                }
                else if(distanceid === 2){ //mahalanobis
                    addClassSelected("maha");
                    v = variance(); //calcolo una volta sola per aggiornamento di data set
                }
            }
            else if(kernelid === 4){
                addClassSelected("rbf");
                console.info("\tRBF");
                console.info("\tKMEANS: \n\tKM1: " + Km1+"\n\tKM2: "+Km2);
                //salvo i dati originali
                dataOLD = data;
                labelsOLD = labels;
                this.KMEANS();
            }
        }

        function myinit(){
            console.info("CREATE DATA CANVAS");
            N=100;
            Ntest = 100;
            setDataSet(2);
            setTrainingSet(2);
            drawTrainingData();
        }

        function myinitTest(){
            console.info("CREATE TEST CANVAS");
            //N=100;
            Km1 = 3;
            Km2 = 3;
            //setDataSet(2);
            //retrainSVM();
            //draw();
            execute();
        }

        function clickBtn(ID) {
            removeAll();
            addClassSelected(ID);
        }
        function addClassSelected(ID) {
            document.getElementById(ID).classList.add("selected");
            // document.getElementById(ID).classList.add("btn");
        }
        function removeAll() {
            let buttons = document.getElementsByTagName("button");
            for (let i=0;i<buttons.length;i++){
                removeAllClasses(buttons.item(i).id);
            }
        }
        function removeAllClasses(ID) {
            document.getElementById(ID).classList.remove("selected");
            // let list = document.getElementById(ID).classList;
            // for(let i=0;i<list.length;i++)
            //     list.remove(list[i]);
        }

        function KMEANS() {
            let separated = this.separateData();
            let kmeans1 = new KMeans({
                canvas: document.getElementById('canvasData'),
                data: separated[0],
                k: Km1
            });
            let kmeans2 = new KMeans({
                canvas: document.getElementById('canvasData'),
                data: separated[1],
                k: Km2
            });
            this.means = new Array(2);
            this.means[0] = kmeans1.means;
            this.means[1] = kmeans2.means;
            let L1 = this.means[0].length;
            let L2 = this.means[1].length;
            let L = L1+L2;
            this.newData = new Array(L);
            this.newLabels = new Array(L);
            for(let i=0;i<L1;i++){
                this.newData[i] = this.means[0][i];
                this.newLabels[i] = 1;
            }
            for(let i=L1;i<L;i++) {
                this.newData[i] = this.means[1][i-L1];
                this.newLabels[i] = -1;
            }
        }
        function separateData() {
            let res = new Array(2);
            res[0] = [];
            res[1] = [];
            for(let i=0;i<data.length;i++){
                if(labels[i]===1)
                    res[0].push(data[i]);
                else res[1].push(data[i]);
            }
            return res;
        }

        </script>

        <!-- distances functions (minkowski, chebyshev, mahalanobis) -->
        <script type="text/javascript" src="js/distances.js"></script>

        <!-- evaluations functions (KNN and RBF) -->
        <script type="text/javascript" src="js/evaluations.js"></script>

        <!-- draw, mouseClick, keyUp, kewDown -->
        <script type="text/javascript">

            function update(){
                CM = trainstats.CM;
                recall = trainstats.recall;
                precision = trainstats.precision;
                accurancy = trainstats.accurancy;
                specificity = trainstats.specificity;
                fMeasure = trainstats.fMeasure;
                useTest = document.getElementById("test").checked;
                if(kernelid<3){ //with kernels
                    data = trainstats.data;
                    labels = trainstats.labels;
                }
                else if(kernelid === 4){ //with rbf
                    KMdata = document.getElementById("kmdata").checked; //update value
                    if( KMdata) {
                        data = this.newData;
                        labels = this.newLabels;
                    }
                }
            }

            function execute() {
                retrainSVM();
                console.info("üî® EXECUTE");
                N = data.length;
                drawTrainingData();

                let app = ctx;
                ctx = ctxTest; //substitute
                draw();
                ctx = app; //return to normal
            }

            function test() {
                console.info("TEST");
                drawDataTest();
            }

            function drawTrainingData() {
                ctx.clearRect(0,0,WIDTH,HEIGHT); //clear canvas
                // draw axes
                drawAxes();
                // draw datapoints
                ctx.strokeStyle = 'rgb(0,0,0)';
                let radius = 5;
                console.info(" ‚úè DRAW DATA: "+N);
                for(let i=0;i<N;i++) {
                    if(labels[i]===1) //positive{
                        ctx.fillStyle = 'rgb(100,200,100)';//green
                    else //negative
                        ctx.fillStyle = 'rgb(200,100,100)'; //red
                    drawCircle(data[i][0]*ss+WIDTH/2, data[i][1]*ss+HEIGHT/2, radius);
                }
            }

            function drawAxes(){
                ctx.beginPath();
                ctx.strokeStyle = 'rgb(50,50,50)';
                ctx.lineWidth = 1;
                ctx.moveTo(0, HEIGHT/2);
                ctx.lineTo(WIDTH, HEIGHT/2);
                ctx.moveTo(WIDTH/2, 0);
                ctx.lineTo(WIDTH/2, HEIGHT);
                ctx.stroke();
            }

            function drawData() {
                ctx.strokeStyle = 'rgb(0,0,0)';
                let radius = 5;
                let value = 0;
                N = data.length;
                console.info(" ‚úè DRAW DATA: "+N);
                let values = [];
                for(let i=0;i<N;i++) {
                    if(kernelid<3) {
                        value = svm.marginOne(data[i]);
                        if(svm.alpha[i]>1e-7) {
                            ctx.lineWidth = 3; // distinguish support vectors
                            radius = Math.floor(3+svm.alpha[i]*5.0/svmC);
                        }
                        else{
                            ctx.lineWidth = 1;
                            radius = 4;
                        }
                    }
                    else if(kernelid===3){
                        value = KNN(data[i][0],data[i][1],K);
                    }
                    else if(kernelid===4){
                        value = RBF(data[i][0],data[i][1]);
                    }

                    //COLORS
                    if(value>0){ //positive
                        if(labels[i]===1) { //positive
                            ctx.fillStyle = 'rgba(100,200,100,0.75)'; //green
                        }
                        else { //false positive
                            ctx.fillStyle = 'rgba(55,55,250,0.75)'; //blue
                        }
                    }
                    else {
                        if(labels[i]===1) { //false negative
                            ctx.fillStyle = 'rgb(240,240,80)'; //yellow
                        }
                        else { //negative
                            ctx.fillStyle = 'rgb(200,100,100)'; //red
                        }
                    }

                    drawCircle(data[i][0]*ss+WIDTH/2, data[i][1]*ss+HEIGHT/2, radius);
                    values.push(value);
                }
                let stats = statisticEval(labels,values);
                updateStats(stats);
            }

            function drawDataTest() {
                ctx.strokeStyle = 'rgb(0,0,0)';
                let radius = 5;
                let value = 0;
                Ntest = datatest.length;
                console.info(" ‚úè DRAW DATA TEST: "+Ntest);
                let values = [];
                for(let i=0;i<Ntest;i++) {
                    if(kernelid<3) {
                        value = svm.marginOne(datatest[i]);
                    }
                    else if(kernelid===3){
                        value = KNN(datatest[i][0],datatest[i][1],K);
                    }
                    else if(kernelid===4){
                        value = RBF(datatest[i][0],datatest[i][1]);
                    }

                    //COLORS
                    if(value>0){ //positive
                        if(labelstest[i]===1) { //positive
                            ctx.fillStyle = 'rgba(100,200,100,0.75)'; //green
                        }
                        else { //false positive
                            ctx.fillStyle = 'rgba(55,55,250,0.75)'; //blue
                        }
                    }
                    else {
                        if(labelstest[i]===1) { //false negative
                            ctx.fillStyle = 'rgb(240,240,80)'; //yellow
                        }
                        else { //negative
                            ctx.fillStyle = 'rgb(200,100,100)'; //red
                        }
                    }

                    drawRectTest(datatest[i][0]*ss+WIDTH/2, datatest[i][1]*ss+HEIGHT/2, radius,radius);
                    values.push(value);
                }
                let stats = statisticEval(labelstest,values);
                updateStatsTest(stats);
            }

            function drawDataGrid() {
                // draw decisions in the grid
                density = 2;
                for(let x=0.0; x<=WIDTH; x+= density) {
                    for(let y=0.0; y<=HEIGHT; y+= density) {
                        ctx.fillStyle = getColor((x-WIDTH/2)/ss,(y-HEIGHT/2)/ss);
                        ctx.fillRect(x-density/2-1, y-density-1, density+2, density+2);
                    }
                }
            }

            function drawDataLinearKernel() {
                let xs= [-5, 5];
                let ys= [0, 0];
                wb.b = -wb.b;
                ys[0]= (-wb.b - wb.w[0]*xs[0])/wb.w[1];
                ys[1]= (-wb.b - wb.w[0]*xs[1])/wb.w[1];
                ctx.fillStyle = 'rgb(0,0,0)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                // wx+b=0 line
                ctx.moveTo(xs[0]*ss+WIDTH/2, ys[0]*ss+HEIGHT/2);
                ctx.lineTo(xs[1]*ss+WIDTH/2, ys[1]*ss+HEIGHT/2);
                // wx+b=1 line
                ctx.moveTo(xs[0]*ss+WIDTH/2, (ys[0]-1.0/wb.w[1])*ss+HEIGHT/2);
                ctx.lineTo(xs[1]*ss+WIDTH/2, (ys[1]-1.0/wb.w[1])*ss+HEIGHT/2);
                // wx+b=-1 line
                ctx.moveTo(xs[0]*ss+WIDTH/2, (ys[0]+1.0/wb.w[1])*ss+HEIGHT/2);
                ctx.lineTo(xs[1]*ss+WIDTH/2, (ys[1]+1.0/wb.w[1])*ss+HEIGHT/2);
                ctx.stroke();

                // draw margin lines for support vectors. The sum of the lengths of these
                // lines, scaled by C is essentially the total hinge loss.
                for(let i=0;i<N;i++) {
                    if(svm.alpha[i]<1e-2) continue;
                    if(labels[i]===1) {
                        ys[0]= (1 -wb.b - wb.w[0]*xs[0])/wb.w[1];
                        ys[1]= (1 -wb.b - wb.w[0]*xs[1])/wb.w[1];
                    } else {
                        ys[0]= (-1 -wb.b - wb.w[0]*xs[0])/wb.w[1];
                        ys[1]= (-1 -wb.b - wb.w[0]*xs[1])/wb.w[1];
                    }
                    let u= (data[i][0]-xs[0])*(xs[1]-xs[0])+(data[i][1]-ys[0])*(ys[1]-ys[0]);
                    u = u/((xs[0]-xs[1])*(xs[0]-xs[1])+(ys[0]-ys[1])*(ys[0]-ys[1]));
                    let xi= xs[0]+u*(xs[1]-xs[0]);
                    let yi= ys[0]+u*(ys[1]-ys[0]);
                    ctx.moveTo(data[i][0]*ss+WIDTH/2, data[i][1]*ss+HEIGHT/2);
                    ctx.lineTo(xi*ss+WIDTH/2, yi*ss+HEIGHT/2);
                }
                ctx.stroke();
            }

            function drawKmeans() {
                // draw means
                ctx.strokeStyle = 'rgb(0,0,0)';
                let radius = 10;
                ctx.lineWidth = 3;
                console.info(" ‚úè DRAW MEANS 1: "+this.means[0].length);
                for(let i=0;i<this.means[0].length;i++) {
                    ctx.fillStyle = 'rgb(100,200,100)'; //green
                    drawCircle(this.means[0][i][0]*ss+WIDTH/2, this.means[0][i][1]*ss+HEIGHT/2, radius);
                }
                console.info(" ‚úè DRAW MEANS 2: "+this.means[1].length);
                for(let i=0;i<this.means[1].length;i++) {
                    ctx.fillStyle = 'rgb(200,100,100)'; //red
                    drawCircle(this.means[1][i][0]*ss+WIDTH/2, this.means[1][i][1]*ss+HEIGHT/2, radius);
                }
            }

            function drawDataKmeans() {
                ctx.strokeStyle = 'rgb(0,0,0)';
                let L = dataOLD.length;
                let value = 0;
                let radius = 0;
                console.info(" ‚úè DRAW TEST: "+L);
                let values = [];
                for(let i=0;i<L;i++) {
                    value = RBF(dataOLD[i][0],dataOLD[i][1]);
                    if(value>0){ //positive
                        if(labelsOLD[i]===1) { //positive
                            ctx.fillStyle = 'rgb(100,200,100)'; //green
                        }
                        else { //false positive
                            ctx.fillStyle = 'rgb(55,55,250)'; //blue
                        }
                    }
                    else {
                        if(labelsOLD[i]===1) { //false negative
                            ctx.fillStyle = 'rgb(240,240,80)'; //yellow
                        }
                        else { //negative
                            ctx.fillStyle = 'rgb(200,100,100)'; //red
                        }
                    }
                    ctx.lineWidth = 1;
                    radius = 6;
                    drawRect(dataOLD[i][0]*ss+WIDTH/2, dataOLD[i][1]*ss+HEIGHT/2,radius,radius);
                    values.push(value);
                }

                let stats = statisticEval(labelsOLD,values);
                this.updateStats(stats);

                data = dataOLD;
                labels = labelsOLD;
            }

            function showUiThings() {
                $("#s0").show();
                $("#s11").show();
                $("#statisticsTraining").show();
                $("#checkboxTest").show();
                if(useTest)
                    $("#statisticsTest").show();
                if(kernelid<3){
                    $("#s1").show();
                    $("#optimization").show();
                    if(kernelid === 1){
                        $("#s2").show();
                    }
                    if(kernelid === 2){
                        $("#s3").show();
                        $("#s4").show();
                    }
                    if(ssca) $("#s5").show();
                }
                if(kernelid===3) {
                    $("#s6").show(); //slider for K in KNN
                    $("#distances").show(); //distances buttons
                    if(distanceid===0)  //minkowski
                        $("#s7").show(); //slider for minkowski P
                }
                if(kernelid===4){
                    $("#s8").show(); //slider for epsilon
                    $("#s9").show(); //slider for Km1
                    $("#s10").show(); //slider for Km2
                    $("#kmeans").show();
                }
            }

            function hideUiThings() {
                $("#optimization").hide();
                $("#distances").hide();
                $("#statisticsTraining").hide();
                $("#statisticsTest").hide();
                $("#kmeans").hide();
                $(".slider_container").hide(); // per nascondere gli slider che non servono
            }

            function getColor(x,y) {
                let color;
                let label;
                if(kernelid<3){
                    let dec= svm.marginOne([x,y]);
                    if(dec>0) color = 'rgb(150,250,150)';
                    else color = 'rgb(250,150,150)';
                }
                else if(kernelid===3) { //KNN
                    label = KNN(x,y,K);
                    if(label === 1) color = 'rgb(150,250,150)'; //green
                    else if(label === 0) color = 'rgb(244,220,66)'; //yellow gold
                    else color = 'rgb(250,150,150)'; //red
                }
                else if(kernelid===4){ //RBF
                    label = RBF(x,y);
                    if(label === 2) color = 'rgb(150,250,150)'; //green
                    else if(label === 0) color = 'rgb(0,0,0)'; //pure black
                    else if(label === 1) color = 'rgb(255,255,50)'; //yellow gold
                    else if(label === -1) color = 'rgb(255,165,50)'; //orange
                    else if(label === -2) color = 'rgb(250,150,150)'; //red
                }
                return color;
            }

            function draw(){

                ctx.clearRect(0,0,WIDTH,HEIGHT);
                update();

                hideUiThings();
                showUiThings();

                drawDataGrid();
                drawAxes();
                drawData();

                if(useTest) {
                    drawDataTest();
                }

                if(kernelid>=3){
                    if(kernelid===4){
                        if(!KMdata) drawKmeans();
                        else drawDataKmeans();
                    }
                }
                else {
                    // if linear kernel, draw decision boundary and margin lines
                    //modified: also if kernel is polynomial and degree is 1: should be equal to linear kernel
                    if( kernelid===0 || (kernelid === 2 && Degree ===  1))
                        drawDataLinearKernel();

                    //per kernelid < 3 and kernelid === 4 and KMdata === true
                    fillData();
                }
            }

            function fillData() {

                ctx.fillStyle= 'rgb(0,0,0)';
                let numsupp=0;
                for(let i=0;i<N;i++) { if(svm.alpha[i] > 1e-5) numsupp++; }
                ctx.fillText("Support vectors: " + numsupp + " / " + N, 10, HEIGHT-10);

            }

            function updateStats(stats) {
                let CM = stats.CM;
                console.info("updateStats");
                let tp = CM[0][0];
                let fp = CM[0][1];
                let fn = CM[1][0];
                let tn = CM[1][1];
                document.getElementById("tp").innerText=tp;
                document.getElementById("fp").innerText=fp;
                document.getElementById("fn").innerText=fn;
                document.getElementById("tn").innerText=tn;
                document.getElementById("precision").innerText=(stats.precision*100).toPrecision(3);
                document.getElementById("recall").innerText=(stats.recall*100).toPrecision(3);
                document.getElementById("accurancy").innerText=(stats.accurancy*100).toPrecision(3);
                document.getElementById("specificity").innerText=(stats.specificity*100).toPrecision(3);
                document.getElementById("fmeasure").innerText=(stats.fMeasure*100).toPrecision(3);

            }

            function updateStatsTest(stats) {
                let CM = stats.CM;
                console.info("updateStatsTest");
                let tp = CM[0][0];
                let fp = CM[0][1];
                let fn = CM[1][0];
                let tn = CM[1][1];
                document.getElementById("tp2").innerText=tp;
                document.getElementById("fp2").innerText=fp;
                document.getElementById("fn2").innerText=fn;
                document.getElementById("tn2").innerText=tn;
                document.getElementById("precision2").innerText=(stats.precision*100).toPrecision(3);
                document.getElementById("recall2").innerText=(stats.recall*100).toPrecision(3);
                document.getElementById("accurancy2").innerText=(stats.accurancy*100).toPrecision(3);
                document.getElementById("specificity2").innerText=(stats.specificity*100).toPrecision(3);
                document.getElementById("fmeasure2").innerText=(stats.fMeasure*100).toPrecision(3);
            }

            function mouseClick(x, y, shiftPressed){

                // add datapoint at location of click
                N = data.length;
                data[N] = [(x-WIDTH/2)/ss, (y-HEIGHT/2)/ss];
                labels[N] = shiftPressed ? 1 : -1;
                if(labels[N]===1) console.info("Added üíö");
                else console.info("Added ‚ù§Ô∏è");
                N += 1;
                drawTrainingData();
                //retrainSVM(); // retrain the svm
            }


            function keyUp(key){

                if(key===13){ //enter
                    /*
                    setDataSet(datasetID);
                    retrainSVM();
                    dirty = true;
                    dirty = true;
                    draw();
                    */
                    execute();
                }
            }

            function keyDown(key){}

        </script>

        <!-- ui functions -->
        <script type="text/javascript" src="js/ui.js"></script>

        <!-- jquery/set functions -->
        <script type="text/javascript" src="js/functions.js"></script>

    </head>

    <body onLoad="NPGinit(10,canvasData), drawTestInit(10,canvasResult)"> <!-- 24 FPS -->
        <div id="info">
            <br /><h1>Support Vector Machine in Javascript (Pratice Mode) üêß‚úåÔ∏è</h1>
            <p>
                Uses SMO algorithm. Find this code on <a href="https://github.com/davide97g/svmjs">Github</a> <br />
                This version is based on the work of Andrej Karpathy. Find his code on <a href="https://github.com/karpathy/svmjs">Github</a>.
            </p>
        </div>
        <div id="options">
            <h3>Instructions</h3>
            <div>
                <strong>Mouse click</strong>: add red data point<br />
                <strong>Shift + mouse click</strong>: add green data point<br />
            </div>
            <h3>Execute</h3>
            <div>
                <button type="button" class="btn" id="gobtn" onclick="clickBtn(id),execute()">Execute</button>
                <button type="button" class="btn" id="testbtn" onclick="clickBtn(id),test()">Test</button>
            </div>
            <h3>Options</h3>
            <div id="kernels" class="opts">
                <h4>Kernels</h4>
                <button id="rbfk" class="btn" onclick="clickBtn(id),changeKernel(1)">RBF</button>
                <button id="poly" class="btn" onclick="clickBtn(id),changeKernel(2)">Polynomial</button>
            </div>
            <div id="optimization" class="opts">
                <h4>Optimization </h4>
                <!-- <button id="SSCAtoggle" onclick="clickBtn(id),toggleSSCA(!ssca)">SSCA off</button> -->
                <label for="ssca">SSCA</label><input type="checkbox" id="ssca"/>
            </div>
            <div id="checkboxTest" class="opts">
                <h4>Test data </h4>
                <label for="test">TEST</label><input type="checkbox" id="test"/>
            </div>
            <div id="evalutation" class="opts">
                <h4>Evaluation functions</h4>
                <button id="knn" class="btn" onclick="clickBtn(id),changeKernel(3)">KNN</button>
                <button id="rbf" class="btn" onclick="clickBtn(id),changeKernel(4)">RBF</button>
            </div>
            <div id="distances" class="opts">
                <h4>Distances</h4>
                <button id="min" class="btn" onclick="clickBtn(id),changeDistance(0)">Minkowski</button>
                <button id="che" class="btn" onclick="clickBtn(id),changeDistance(1)">Chebyshev</button>
                <button id="maha" class="btn" onclick="clickBtn(id),changeDistance(2)">Mahalanobis</button>
            </div>
            <div id="kmeans" class="opts">
                <!--<button id="kmdata" onclick="clickBtn(id),setKMdata(!KMdata)">Kmeans as Data</button>-->
                <label for="kmdata">Kmeans as Data</label><input type="checkbox" id="kmdata"/>
            </div>
            <h3>Datasets</h3>

            <div id="s0" class="slider_container">
                <span id="nport">N = 100</span>
                <div id="slider0"></div>
            </div>
            <div id="s11" class="slider_container">
                <span id="ntestport">N test = 100</span>
                <div id="slider11"></div>
            </div>

            <div class="datasets">
                <!-- <button class="keys btn" id="databtn0" onclick="clickBtn(id),setDataSet(0),execute()">Original</button> -->
                <button class="keys btn orange" id="databtn1" onclick="clickBtn(id),setDataSet(1),execute()">Random</button>
                <button class="keys btn blue" id="databtn2" onclick="clickBtn(id),setDataSet(2),execute()">Circle</button>
                <button class="keys btn yellow" id="databtn3" onclick="clickBtn(id),setDataSet(3),execute()">ExclusiveOr</button>
                <button class="keys btn purple" id="databtn4" onclick="clickBtn(id),setDataSet(4),execute()">Gaussian</button>
                <button class="keys btn" id="databtn5" onclick="clickBtn(id),setDataSet(5),execute()">Spiral</button>
                <!--<div><span class="keys">"0"</span>Original</div>
                <div><span class="keys">"1"</span>Random</div>
                <div><span class="keys">"2"</span>Circle</div>
                <div><span class="keys">"3"</span>ExclusiveOr</div>
                <div><span class="keys">"4"</span>Gaussian</div>
                <div><span class="keys">"5"</span>Spiral</div> -->
            </div>

            <div id="values">
                <h3>Values</h3>
                <div id="s1" class="slider_container">
                    <span id="creport">C = 1.0</span>
                    <div id="slider1"></div>
                </div>
                <div id="s2" class="slider_container">
                    <span id="sigreport">RBF Kernel sigma = 1.0 </span>
                    <div id="slider2"></div>
                </div>
                <div id="s3" class="slider_container">
                    <span id="degport">Polynomial Kernel degree = 2</span>
                    <div id="slider3"></div>
                </div>
                <div id="s4" class="slider_container">
                    <span id="infport">Polynomial Kernel influence = 0</span>
                    <div id="slider4"></div>
                </div>
                <div id="s5" class="slider_container">
                    <span id="ubport">Upper bound = 0.5</span>
                    <div id="slider5"></div>
                </div>
                <div id="s6" class="slider_container">
                    <span id="kport">K: 1</span>
                    <div id="slider6"></div>
                </div>
                <div id="s7" class="slider_container">
                    <span id="pport">Minkowski with P: 2</span>
                    <div id="slider7"></div>
                </div>
                <div id="s8" class="slider_container">
                    <span id="epsilonport">Epsilon : 0.1</span>
                    <div id="slider8"></div>
                </div>
                <div id="s9" class="slider_container">
                    <span id="kmeans1port">K1 (Means) : 3</span>
                    <div id="slider9"></div>
                </div>
                <div id="s10" class="slider_container">
                    <span id="kmeans2port">K2 (Means) : 3</span>
                    <div id="slider10"></div>
                </div>
            </div>
        </div>

        <div id="draw">
            <canvas id="canvasData" width="400" height="400">Browser not supported for Canvas. Get a real browser.
            </canvas>
            <canvas id="canvasResult" width="400" height="400">Browser not supported for Canvas. Get a real browser.
            </canvas>
            <div id="statisticsTraining">
                <h3>Statistics Training</h3>
                <table id="CMtable">
                    <thead>
                    <tr>
                        <th colspan="2">Confusion Matrix</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td id="tp">-</td>
                        <td id="fp">-</td>
                    </tr>
                    <tr>
                        <td id="fn">-</td>
                        <td id="tn">-</td>
                    </tr>
                    </tbody>
                </table>
                <div class="stats">
                    <div>
                        Precision:
                        <span class="value" id="precision">-</span>
                        %
                    </div>
                    <div>
                        Recall:
                        <span class="value" id="recall">-</span>
                        %
                    </div>
                    <div>
                        Accurancy:
                        <span class="value" id="accurancy">-</span>
                        %
                    </div>
                    <div>
                        Specificity:
                        <span class="value" id="specificity">-</span>
                        %
                    </div>
                    <div>
                        F-Measure:
                        <span class="value" id="fmeasure">-</span>
                        %
                    </div>
                </div>
            </div>
            <div id="statisticsTest">
                <h3>Statistics Test</h3>
                <table id="CMtableTest">
                <thead>
                <tr>
                    <th colspan="2">Confusion Matrix Test</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td id="tp2">-</td>
                    <td id="fp2">-</td>
                </tr>
                <tr>
                    <td id="fn2">-</td>
                    <td id="tn2">-</td>
                </tr>
                </tbody>
            </table>
                <div class="stats">
                <div>
                    Precision:
                    <span class="value" id="precision2">-</span>
                    %
                </div>
                <div>
                    Recall:
                    <span class="value" id="recall2">-</span>
                    %
                </div>
                <div>
                    Accurancy:
                    <span class="value" id="accurancy2">-</span>
                    %
                </div>
                <div>
                    Specificity:
                    <span class="value" id="specificity2">-</span>
                    %
                </div>
                <div>
                    F-Measure:
                    <span class="value" id="fmeasure2">-</span>
                    %
                </div>
            </div>
            </div>
        </div>

    </body>
</html>
