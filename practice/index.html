<!DOCTYPE html>
<html lang="it">
    <head>
        <title>SVM Javascript</title>
        <link type="text/css" href="./jqueryui/css/ui-lightness/jquery-ui-1.8.21.custom.css" rel="Stylesheet" />
        <link type="text/css" rel="stylesheet" href="style/style.css"/>
        <script type="text/javascript" src="./jqueryui/js/jquery-1.7.2.min.js"></script>
        <script type="text/javascript" src="./jqueryui/js/jquery-ui-1.8.21.custom.min.js"></script>
        <script src="./npg_include/npgmain.js"></script>

        <script src="../lib/stats.js"></script>
        <script src="../lib/utils.js"></script>
        <script src="../lib/kernels.js"></script>

        <script src="./js/kmeans.js"></script>
        <script src="../lib/svm.js"></script>
        <script src="../lib/svmo.js"></script>

        <script type="text/javascript" src="./js/generator.js"></script>
        <!-- Declaration and initialization -->
        <script type="text/javascript">

        /*
        This demo includes npg library (notpygamejs) that I wrote a while ago. It can
        be found on my Github page (https://github.com/karpathy/notpygamejs). It's a
        quick and dirty canvas wrapper that has some helped functions I use often.
        It's main use is to contain a main loop and expose methods update(), draw(),
        as well as some events keyUp(), mouseClick() etc.
        */

        let N = 10; //number of data points
        let data = new Array(N);
        let labels = new Array(N);
        let dataOLD = new Array(N);
        let labelsOLD = new Array(N);
        let wb; // weights and offset structure
        let ss= 50.0; // scaling factor for drawing
        let svm= new svmjs.SVM();
        let svmo = new svmojs.SVMO();
        let dirty= true;
        let rbfKernelSigma = 0.5;
        let svmC = 1.0;
        let memo = true;

        let trainstats = {
            data: null,
            labels: null,
            CM:null,
            recall: null,
            precision : null,
            accurancy : null,
            specificity : null,
            fMeasure : null
        };

        let kernelid= 4;
        let Degree = 2;
        let Influence = 0;
        let ssca = false;
        let ub = 0.5;
        let CM;
        let recall;
        let precision;
        let accurancy;
        let specificity;
        let fMeasure;
        let K = 1; //for KNN
        let P = 2; //for minkowski
        let v; //array of variances
        let distanceid = 0; //for distances in KNN evalutations
        let datasetID = 1; //initially random
        let Epsilon = 0.1; //for rbf function evaluation
        let Km1 = 3; //K for kmeans
        let Km2 = 3; //K for kmeans
        let KMdata = false; //use or not Kmeans as data

        function setDataSet(id) {
            datasetID = id;
            if(id===0){
                /*
                data[0]=[-0.4326  ,  1.1909 ];
                data[1]= [3.0, 4.0];
                data[2]=[0.1253 , -0.0376   ];
                data[3]=[0.2877 ,   0.3273  ];
                data[4]=[-1.1465 ,   0.1746 ];
                data[5]=[1.8133 ,   2.1139  ];
                data[6]=[2.7258 ,   3.0668  ];
                data[7]=[1.4117 ,   2.0593  ];
                data[8]=[4.1832 ,   1.9044  ];
                data[9]=[1.8636 ,   1.1677  ];

                labels[0]= 1;
                labels[1]= 1;
                labels[2]= 1;
                labels[3]= 1;
                labels[4]= 1;
                labels[5]= -1;
                labels[6]= -1;
                labels[7]= -1;
                labels[8]= -1;
                labels[9]= -1;
                */
                data = new Array(11);
                labels = new Array(11);
                data[0]=[-0, -0.49];
                data[1]=[-0.29, 0.85];
                data[2]=[0.34, 0.33];
                data[3]=[-0.87, 0.56];
                data[4]=[-0.86, -0.33];
                data[5]=[1.12, -0.77];
                data[6]=[-0, -0.49];
                data[7]=[-0.29, 0.85];
                data[8]=[0.34, 0.33];
                data[9]=[-0.87, 0.56];
                data[10]=[-0.86, -0.33];
                data[11]=[1.12, -0.77];

                labels[0]= 1;
                labels[1]= 1;
                labels[2]= 1;
                labels[3]= 1;
                labels[4]= 1;
                labels[5]= 1;
                labels[6]= -1;
                labels[7]= -1;
                labels[8]= -1;
                labels[9]= -1;
                labels[10]= -1;
                labels[11]= -1;

            }
            else if(id===1){
                let res = randomData(N);
                data = res.data;
                labels = res.labels;
            }
            else if(id===2){
                let res = circelData(N);
                data = res.data;
                labels = res.labels;
            }
            else if(id===3){
                let res = exclusiveOrData(N);
                data = res.data;
                labels = res.labels;
            }
            else if(id===4){
                let res = gaussianData(N);
                data = res.data;
                labels = res.labels;
            }
            else if(id===5){
                let res = spiralData(N);
                data = res.data;
                labels = res.labels;
            }
        }

        function retrainSVM() {
            console.clear();
            console.info("üêµ DATASET "+datasetID);
            if(kernelid === 0) {
                kernelid = 2;
                Degree = 1;
                retrainSVM();
            }
            else if(kernelid === 1) {
                addClassSelected("rbfk");
                trainstats= svm.train(data, labels, { kernel: 'rbf', rbfsigma: rbfKernelSigma, C: svmC, SSCA: ssca, UB: ub, memoize: memo});
            }
            else if(kernelid === 2){
                addClassSelected("poly");
                trainstats= svm.train(data, labels, { kernel: 'poly', degree: Degree, influence: Influence, C: svmC, SSCA: ssca, UB: ub, memoize: memo});
                if(Degree === 1)
                    wb = svm.getWeights();
            }
            else if(kernelid === 3){
                addClassSelected("knn");
                console.info("\tKNN: "+K);
                console.info("\tDISTANCE: "+distanceF.name);
                if(distanceid===0){
                    addClassSelected("min");
                    console.info("\tP = "+P);
                }
                else if(distanceid === 1 ){
                    addClassSelected("che");
                }
                else if(distanceid === 2){ //mahalanobis
                    addClassSelected("maha");
                    v = variance(); //calcolo una volta sola per aggiornamento di data set
                }
            }
            else if(kernelid === 4){
                addClassSelected("rbf");
                console.info("\tRBF");
                console.info("\tKMEANS: \n\tKM1: " + Km1+"\n\tKM2: "+Km2);
                dataOLD = data;
                labelsOLD = labels;
                this.KMEANS();
            }

            //svmo.setUp(data,alpha,labels,b,{ kernel: 'poly', degree: Degree, influence: Influence, C: svmC, SSCA: ssca, UB: ub, memoize: memo});

            dirty= true; // to redraw screen
        }

        function myinit(){
            N=100;
            Km1 = 3;
            Km2 = 3;
            setDataSet(2);
            retrainSVM();
        }

        function clickBtn(ID) {
            removeAll();
            addClassSelected(ID);
        }
        function addClassSelected(ID) {
            document.getElementById(ID).classList.add("selected");
        }
        function removeAll() {
            let buttons = document.getElementsByTagName("button");
            for (let i=0;i<buttons.length;i++){
                removeAllClasses(buttons.item(i).id);
            }
        }
        function removeAllClasses(ID) {
            let list = document.getElementById(ID).classList;
            for(let i=0;i<list.length;i++)
                list.remove(list[i]);
        }

        function KMEANS() {
            let separated = this.separateData();
            let kmeans1 = new KMeans({
                canvas: document.getElementById('NPGcanvas'),
                data: separated[0],
                k: Km1
            });
            let kmeans2 = new KMeans({
                canvas: document.getElementById('NPGcanvas'),
                data: separated[1],
                k: Km2
            });
            this.means = new Array(2);
            this.means[0] = kmeans1.means;
            this.means[1] = kmeans2.means;
            let L1 = this.means[0].length;
            let L2 = this.means[1].length;
            let L = L1+L2;
            this.newData = new Array(L);
            this.newLabels = new Array(L);
            for(let i=0;i<L1;i++){
                this.newData[i] = this.means[0][i];
                this.newLabels[i] = 1;
            }
            for(let i=L1;i<L;i++) {
                this.newData[i] = this.means[1][i-L1];
                this.newLabels[i] = -1;
            }
            //console.table(this.newData);
            //console.table(this.newLabels);
        }
        function separateData() {
            let res = new Array(2);
            res[0] = [];
            res[1] = [];
            for(let i=0;i<data.length;i++){
                if(labels[i]===1)
                    res[0].push(data[i]);
                else res[1].push(data[i]);
            }
            return res;
        }

        </script>

        <!-- distances functions (minkowski, chebyshev, mahalanobis) -->
        <script type="text/javascript" src="js/distances.js"></script>

        <!-- evaluations functions (KNN and RBF) -->
        <script type="text/javascript" src="js/evaluations.js"></script>

        <!-- draw, mouseClick, keyUp, kewDown -->
        <script type="text/javascript">

            function update(){
                CM = trainstats.CM;
                recall = trainstats.recall;
                precision = trainstats.precision;
                accurancy = trainstats.accurancy;
                specificity = trainstats.specificity;
                fMeasure = trainstats.fMeasure;
                if(kernelid<3){
                    data = trainstats.data;
                    labels = trainstats.labels;
                }
                if(kernelid === 4 && KMdata){
                    // console.table(data);
                    // console.table(labels);
                    data = this.newData;
                    labels = this.newLabels;
                    // console.info("now they are means");
                    // console.table(data);
                    // console.table(labels);
                }
            }

            function draw(){
                if(!dirty) return;
                dirty = false;

                ctx.clearRect(0,0,WIDTH,HEIGHT);
                update();

                let optimization = $("#optimization");
                let distances = $("#distances");
                let confusion_matrix = $("#CMtable");
                confusion_matrix.hide();
                distances.hide();
                optimization.hide();

                $(".slider_container").hide(); // per nascondere gli slider che non servono

                if(datasetID !== 0)
                    $("#s0").show();

                if(kernelid>=3){

                    if(kernelid===3) {
                        $("#s6").show(); //slider for K in KNN
                        distances.show();
                        if(distanceid===0)  //minkowski
                            $("#s7").show(); //slider for minkowski
                    }
                    if(kernelid===4){
                        $("#s8").show(); //slider for epsilon
                        $("#s9").show(); //slider for Km1
                        $("#s10").show(); //slider for Km2

                    }

                    // draw decisions in the grid
                    let density = 1;
                    for(let x=0.0; x<=WIDTH; x+= density) {
                        for(let y=0.0; y<=HEIGHT; y+= density) {
                            let label;
                            if(kernelid===3) { //KNN
                                label = KNN((x - WIDTH / 2) / ss, (y - HEIGHT / 2) / ss,K);
                                if(label === 1) ctx.fillStyle = 'rgb(150,250,150)'; //green
                                //else if(label === 0) ctx.fillStyle = 'rgb(191,244,66)'; //yellow lime
                                //else if(label === 0) ctx.fillStyle = 'rgb(244,161,66)'; //orange
                                else if(label === 0) ctx.fillStyle = 'rgb(244,220,66)'; //yellow gold
                                else ctx.fillStyle = 'rgb(250,150,150)'; //red
                            }
                            else if(kernelid===4){ //RBF
                                label = RBF((x - WIDTH / 2) / ss, (y - HEIGHT / 2) / ss);
                                if(label === 2) ctx.fillStyle = 'rgb(150,250,150)'; //green
                                else if(label === 0) ctx.fillStyle = 'rgb(0,0,0)'; //pure black
                                else if(label === 1) ctx.fillStyle = 'rgb(255,255,50)'; //yellow gold
                                else if(label === -1) ctx.fillStyle = 'rgb(255,165,50)'; //orange
                                else if(label === -2) ctx.fillStyle = 'rgb(250,150,150)'; //red
                            }

                            ctx.fillRect(x-density/2-1, y-density-1, density+2, density+2);
                        }
                    }

                    // draw axes
                    ctx.beginPath();
                    ctx.strokeStyle = 'rgb(50,50,50)';
                    ctx.lineWidth = 1;
                    ctx.moveTo(0, HEIGHT/2);
                    ctx.lineTo(WIDTH, HEIGHT/2);
                    ctx.moveTo(WIDTH/2, 0);
                    ctx.lineTo(WIDTH/2, HEIGHT);
                    ctx.stroke();

                    // draw datapoints
                    ctx.strokeStyle = 'rgb(0,0,0)';
                    N = data.length;
                    let radius = 5;
                    console.info(" ‚úè DRAW: "+N);
                    for(let i=0;i<N;i++) {
                        if(labels[i]===1) //positive
                        {
                            ctx.fillStyle = 'rgb(100,200,100)';//green
                        }
                        else //negative
                        {
                            ctx.fillStyle = 'rgb(200,100,100)'; //red
                        }
                        drawCircle(data[i][0]*ss+WIDTH/2, data[i][1]*ss+HEIGHT/2, radius);
                    }
                    if(kernelid===4){
                        //without Kmeans optimization
                        if(!KMdata){
                            // draw means
                            ctx.strokeStyle = 'rgb(0,0,0)';
                            radius = 10;
                            ctx.lineWidth = 3;
                            console.info(" ‚úè DRAW MEANS 1: "+this.means[0].length);
                            for(let i=0;i<this.means[0].length;i++) {
                                ctx.fillStyle = 'rgb(100,200,100)'; //green
                                drawCircle(this.means[0][i][0]*ss+WIDTH/2, this.means[0][i][1]*ss+HEIGHT/2, radius);
                            }
                            console.info(" ‚úè DRAW MEANS 2: "+this.means[1].length);
                            for(let i=0;i<this.means[1].length;i++) {
                                ctx.fillStyle = 'rgb(200,100,100)'; //red
                                drawCircle(this.means[1][i][0]*ss+WIDTH/2, this.means[1][i][1]*ss+HEIGHT/2, radius);
                            }
                        }
                        else{
                            // draw test data
                            ctx.strokeStyle = 'rgb(0,0,0)';
                            let L = dataOLD.length;
                            let value = 0;
                            let radius = 0;
                            console.info(" ‚úè DRAW TEST: "+L);
                            let CM = [[0,0],[0,0]];
                            for(let i=0;i<L;i++) {
                                value = RBF(dataOLD[i][0],dataOLD[i][1]);
                                if(value>0){ //positive
                                    if(labelsOLD[i]===1) { //positive
                                        ctx.fillStyle = 'rgb(100,200,100)'; //green
                                        CM[0][0]++;
                                    }
                                    else { //false positive
                                        ctx.fillStyle = 'rgb(55,55,250)'; //blue
                                        CM[0][1]++;
                                    }
                                }
                                else {
                                    if(labelsOLD[i]===1) { //false negative
                                        ctx.fillStyle = 'rgb(240,240,80)'; //yellow
                                        CM[1][0]++;
                                    }
                                    else { //negative
                                        ctx.fillStyle = 'rgb(200,100,100)'; //red
                                        CM[1][1]++;
                                    }
                                }
                                ctx.lineWidth = 1;
                                radius = 6;
                                //drawCircle(dataOLD[i][0]*ss+WIDTH/2, dataOLD[i][1]*ss+HEIGHT/2,radius);
                                drawRect(dataOLD[i][0]*ss+WIDTH/2, dataOLD[i][1]*ss+HEIGHT/2,radius,radius);
                            }
                            //Confusion Matrix
                            confusion_matrix.show();
                            this.updateCM(CM);
                        }
                    }

                    return;
                }

                optimization.show();

                // draw decisions in the grid
                let density= 2;
                for(let x=0.0; x<=WIDTH; x+= density) {
                    for(let y=0.0; y<=HEIGHT; y+= density) {
                        let dec= svm.marginOne([(x-WIDTH/2)/ss, (y-HEIGHT/2)/ss]);
                        if(dec>0) ctx.fillStyle = 'rgb(150,250,150)';
                        else ctx.fillStyle = 'rgb(250,150,150)';
                        ctx.fillRect(x-density/2-1, y-density-1, density+2, density+2);
                    }
                }

                // draw axes
                ctx.beginPath();
                ctx.strokeStyle = 'rgb(50,50,50)';
                ctx.lineWidth = 1;
                ctx.moveTo(0, HEIGHT/2);
                ctx.lineTo(WIDTH, HEIGHT/2);
                ctx.moveTo(WIDTH/2, 0);
                ctx.lineTo(WIDTH/2, HEIGHT);
                ctx.stroke();

                // draw datapoints. Draw support vectors larger
                ctx.strokeStyle = 'rgb(0,0,0)';
                //N = data.length;
                let value = 0;
                let radius = 0;
                console.info(" ‚úè DRAW: "+N);
                for(let i=0;i<N;i++) {
                    value = svm.marginOne(data[i]);
                    if(value>0){ //positive
                        if(labels[i]===1) //positive
                            ctx.fillStyle = 'rgb(100,200,100)'; //green
                        else { //false positive
                            ctx.fillStyle = 'rgb(55,55,250)'; //blue
                        }
                    }
                    else {
                        if(labels[i]===1) //false negative
                            ctx.fillStyle = 'rgb(240,240,80)'; //yellow
                        else //negative
                            ctx.fillStyle = 'rgb(200,100,100)'; //red
                    }

                    if(svm.alpha[i]>1e-7) {
                        ctx.lineWidth = 3; // distinguish support vectors
                        radius = Math.floor(3+svm.alpha[i]*5.0/svmC);
                    }
                    else{
                        ctx.lineWidth = 1;
                        radius = 4;
                    }

                    drawCircle(data[i][0]*ss+WIDTH/2, data[i][1]*ss+HEIGHT/2, radius);
                }

                // if linear kernel, draw decision boundary and margin lines
                //modified: also if kernel is polynomial and degree is 1: should be equal to linear kernel
                if( kernelid===0 || (kernelid === 2 && Degree ===  1)) {

                    let xs= [-5, 5];
                    let ys= [0, 0];
                    wb.b = -wb.b;
                    ys[0]= (-wb.b - wb.w[0]*xs[0])/wb.w[1];
                    ys[1]= (-wb.b - wb.w[0]*xs[1])/wb.w[1];
                    ctx.fillStyle = 'rgb(0,0,0)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    // wx+b=0 line
                    ctx.moveTo(xs[0]*ss+WIDTH/2, ys[0]*ss+HEIGHT/2);
                    ctx.lineTo(xs[1]*ss+WIDTH/2, ys[1]*ss+HEIGHT/2);
                    // wx+b=1 line
                    ctx.moveTo(xs[0]*ss+WIDTH/2, (ys[0]-1.0/wb.w[1])*ss+HEIGHT/2);
                    ctx.lineTo(xs[1]*ss+WIDTH/2, (ys[1]-1.0/wb.w[1])*ss+HEIGHT/2);
                    // wx+b=-1 line
                    ctx.moveTo(xs[0]*ss+WIDTH/2, (ys[0]+1.0/wb.w[1])*ss+HEIGHT/2);
                    ctx.lineTo(xs[1]*ss+WIDTH/2, (ys[1]+1.0/wb.w[1])*ss+HEIGHT/2);
                    ctx.stroke();

                    // draw margin lines for support vectors. The sum of the lengths of these
                    // lines, scaled by C is essentially the total hinge loss.
                    for(let i=0;i<N;i++) {
                        if(svm.alpha[i]<1e-2) continue;
                        if(labels[i]===1) {
                            ys[0]= (1 -wb.b - wb.w[0]*xs[0])/wb.w[1];
                            ys[1]= (1 -wb.b - wb.w[0]*xs[1])/wb.w[1];
                        } else {
                            ys[0]= (-1 -wb.b - wb.w[0]*xs[0])/wb.w[1];
                            ys[1]= (-1 -wb.b - wb.w[0]*xs[1])/wb.w[1];
                        }
                        let u= (data[i][0]-xs[0])*(xs[1]-xs[0])+(data[i][1]-ys[0])*(ys[1]-ys[0]);
                        u = u/((xs[0]-xs[1])*(xs[0]-xs[1])+(ys[0]-ys[1])*(ys[0]-ys[1]));
                        let xi= xs[0]+u*(xs[1]-xs[0]);
                        let yi= ys[0]+u*(ys[1]-ys[0]);
                        ctx.moveTo(data[i][0]*ss+WIDTH/2, data[i][1]*ss+HEIGHT/2);
                        ctx.lineTo(xi*ss+WIDTH/2, yi*ss+HEIGHT/2);
                    }
                    ctx.stroke();
                }

                ctx.fillStyle= 'rgb(0,0,0)';

                ctx.fillText("Recall " + (recall*100).toPrecision(3) +"%" , 10, HEIGHT-210);
                ctx.fillText("Precision " + (precision*100).toPrecision(3) +"%" , 10, HEIGHT-190);
                ctx.fillText("Accurancy " + (accurancy*100).toPrecision(3) +"%" , 10, HEIGHT-170);
                ctx.fillText("Specificity " + (specificity*100).toPrecision(3) +"%" , 10, HEIGHT-150);
                ctx.fillText("FMeasure " + (fMeasure*100).toPrecision(3) +"%" , 10, HEIGHT-130);
                ctx.fillText("Converged in " + trainstats.iters + " iterations.", 10, HEIGHT-30);

                let numsupp=0;
                for(let i=0;i<N;i++) { if(svm.alpha[i] > 1e-5) numsupp++; }
                ctx.fillText("Number of support vectors: " + numsupp + " / " + N, 10, HEIGHT-50);

                if(kernelid === 2){
                    ctx.fillText("Using Polynomial kernel with degree = " + Degree, 10, HEIGHT - 70);
                    ctx.fillText("Influence = " + Influence, 10, HEIGHT - 90);
                    $("#s3").show();
                    $("#s4").show();
                }
                if(kernelid === 1){
                    ctx.fillText("Using Rbf kernel with sigma = " + rbfKernelSigma.toPrecision(2), 10, HEIGHT - 70);
                    $("#s2").show();
                }
                if(kernelid === 0) ctx.fillText("Using Linear kernel", 10, HEIGHT - 70);

                if(ssca) $("#s5").show();

                $("#s1").show();

                ctx.fillText("C = " + svmC.toPrecision(2), 10, HEIGHT - 110);
            }

            function updateCM(CM) {
                console.info("updateCM");
                let tp = CM[0][0];
                let fp = CM[0][1];
                let fn = CM[1][0];
                let tn = CM[1][1];
                document.getElementById("tp").innerText=tp;
                document.getElementById("fp").innerText=fp;
                document.getElementById("fn").innerText=fn;
                document.getElementById("tn").innerText=tn;
            }

            function mouseClick(x, y, shiftPressed){

                // add datapoint at location of click
                data[N] = [(x-WIDTH/2)/ss, (y-HEIGHT/2)/ss];
                labels[N] = shiftPressed ? 1 : -1;
                N += 1;

                // retrain the svm
                retrainSVM();
            }

            function keyUp(key){

                if(key===13){ //enter
                    setDataSet(datasetID);
                    retrainSVM();
                }
                if(key===187){ //+
                    if(datasetID!==0){
                        N+=10;
                        setDataSet(datasetID);
                        retrainSVM();
                    }
                }
                if(key===48){ //0
                    N=10;
                    $("#nport").value = N;
                    data = data.splice(0,10);
                    setDataSet(0);
                    retrainSVM();
                }
                else if(key===49){ //1
                    //N = 100;
                    setDataSet(1);
                    retrainSVM();
                }
                else if(key===50){ //2
                    //N = 100;
                    setDataSet(2);
                    retrainSVM();
                }
                else if(key===51){ //3
                    //N = 100;
                    setDataSet(3);
                    retrainSVM();
                }
                else if(key===52){ //4
                    //N = 100;
                    setDataSet(4);
                    retrainSVM();
                }
                else if(key===53){ //5
                    //N = 100;
                    setDataSet(5);
                    retrainSVM();
                }
            }

            function keyDown(key){}

        </script>

        <!-- ui functions -->
        <script type="text/javascript" src="js/ui.js"></script>

        <!-- jquery/set functions -->
        <script type="text/javascript" src="js/functions.js"></script>

    </head>

    <body onLoad="NPGinit(10);"> <!-- 24 FPS -->
        <div id="info">
            <br /><h1>Support Vector Machine in Javascript (Pratice Mode) üêß‚úåÔ∏è</h1>
            <p>
                Uses SMO algorithm. Find this code on <a href="https://github.com/davide97g/svmjs">Github</a> <br />
                This version is based on the work of Andrej Karpathy. Find his code on <a href="https://github.com/karpathy/svmjs">Github</a>.
            </p>
        </div>
        <div id="options">
            <h3>Options</h3>
            <div id="kernels" class="opts">
                <b>Kernels: </b>
                <!-- <button id="linear" onclick="clickBtn(id),changeKernel(0)">Linear Kernel</button> -->
                <button id="rbfk" onclick="clickBtn(id),changeKernel(1)">RBF Kernerl</button>
                <button id="poly" onclick="clickBtn(id),changeKernel(2)">Polynomial Kernel</button>
            </div>
            <div id="optimization" class="opts">
                <b>Optimization: </b>
                <button id="SSCAtoggle" onclick="clickBtn(id),toggleSSCA(!ssca)">SSCA off</button>
            </div>
            <div id="evalutation" class="opts">
                <b>Evaluation functions:</b>
                <button id="knn" onclick="clickBtn(id),changeKernel(3)">KNN</button>
                <button id="rbf" onclick="clickBtn(id),changeKernel(4)">RBF function</button>
            </div>
            <div id="distances" class="opts">
                <b>Distances functions:</b>
                <button id="min" onclick="clickBtn(id),changeDistance(0)">Minkowski</button>
                <button id="che" onclick="clickBtn(id),changeDistance(1)">Chebyshev</button>
                <button id="maha" onclick="clickBtn(id),changeDistance(2)">Mahalanobis</button>
            </div>
            <div id="kmeans" class="opts">
                <button id="kmdata" onclick="clickBtn(id),setKMdata(!KMdata)">Kmeans as Data</button>
            </div>
            <h3>Datasets</h3>
            <div id="s0" class="slider_container">
                <div id="slider0"></div>
                <br/>
                <span id="nport">N = 100</span>
            </div>
            <div class="datasets">
                <button class="keys" id="databtn0" onclick="clickBtn(id),setDataSet(0)">Original</button>
                <div><span class="keys">"0"</span>Original</div>
                <div><span class="keys">"1"</span>Random</div>
                <div><span class="keys">"2"</span>Circle</div>
                <div><span class="keys">"3"</span>ExclusiveOr</div>
                <div><span class="keys">"4"</span>Gaussian</div>
                <div><span class="keys">"5"</span>Spiral</div>
            </div>
        </div>
        <div id="instructions">
            <h3>Instructions</h3>
            <div>
                <strong>Mouse click</strong>: add red data point<br />
                <strong>Shift + mouse click</strong>: add green data point<br />
            </div>
            <canvas id="NPGcanvas" width="450" height="450">Browser not supported for Canvas. Get a real browser.
            </canvas>
        </div>

        <div id="values">
            <h3>Values</h3>
            <table id="CMtable">
                <thead>
                <tr>
                    <th colspan="2">Confusion Matrix</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td id="tp">1</td>
                    <td id="fp">2</td>
                </tr>
                <tr>
                    <td id="fn">3</td>
                    <td id="tn">4</td>
                </tr>
                </tbody>
            </table>
            <div id="s1" class="slider_container">
                <span id="creport">C = 1.0</span>
                <div id="slider1"></div>
            </div>
            <div id="s2" class="slider_container">
                <span id="sigreport">RBF Kernel sigma = 1.0 </span>
                <div id="slider2"></div>
            </div>
            <div id="s3" class="slider_container">
                <span id="degport">Polynomial Kernel degree = 2</span>
                <div id="slider3"></div>
            </div>
            <div id="s4" class="slider_container">
                <span id="infport">Polynomial Kernel influence = 0</span>
                <div id="slider4"></div>
            </div>
            <div id="s5" class="slider_container">
                <span id="ubport">Upper bound = 0.5</span>
                <div id="slider5"></div>
            </div>
            <div id="s6" class="slider_container">
                <span id="kport">K: 1</span>
                <div id="slider6"></div>
            </div>
            <div id="s7" class="slider_container">
                <span id="pport">Minkowski with P: 2</span>
                <div id="slider7"></div>
            </div>
            <div id="s8" class="slider_container">
                <span id="epsilonport">Epsilon : 0.1</span>
                <div id="slider8"></div>
            </div>
            <div id="s9" class="slider_container">
                <span id="kmeans1port">K1 (Means) : 3</span>
                <div id="slider9"></div>
            </div>
            <div id="s10" class="slider_container">
                <span id="kmeans2port">K2 (Means) : 3</span>
                <div id="slider10"></div>
            </div>
        </div>
    </body>
</html>
